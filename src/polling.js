import got from "got"
import * as constants from "./constants.js"

export async function poll({
                             apiUrl,
                             collectionToken,
                             customerId,
                             eventId,
                             onStatusUpdate,
                             pollTimeout = 10,
                             pollInterval = 5000
                           }) {
  const pollingUrl = `https://${apiUrl}${constants.PollingEndpoint}/${eventId}`
  const headers = {
    [constants.LightlyticsTokenKey]: collectionToken,
  }

  let pollCount = 0
  let lastStatus = ""
  while (pollCount < (pollTimeout * 60 * 1000) / pollInterval) {
    await new Promise(resolve => setTimeout(resolve, pollInterval))
    pollCount++

    const response = await got.get(pollingUrl, {
      responseType: "json",
      headers,
    });

    const details_url = `https://${apiUrl}/w/${customerId}/simulations/${eventId}`
    const status = statusToGithubChecks(response.body?.status || 'pending')
    const markdownOutput = getConclusionComment(status.conclusion, response.body?.violations, details_url)

    if ((pollCount >= (pollTimeout * 60 * 1000) / pollInterval) && !status.conclusion) {
      console.log(`Simulation result timed out with status: ${status.status}`)
      status.conclusion = 'neutral' // 'timed_out' will not allow merging
      status.status = 'completed'
    }

    if (lastStatus !== response.body?.status) {
      lastStatus = response.body?.status
      onStatusUpdate(status, markdownOutput)
    }

    if (status.conclusion) {
      break
    }
  }
}

function statusToGithubChecks(status) {
  switch (status) {
    case 'pending':
      return {
        status: 'queued'
      }
    case 'processing':
      return {
        status: 'in_progress'
      }
    case 'error':
      return {
        status: 'completed', // queued, in_progress, completed
        conclusion: 'neutral' // action_required, cancelled, failure, neutral, success, skipped, timed_out
      }
    case 'failed':
      return {
        status: 'completed',
        conclusion: 'failure'
      }
    default:
    case 'done':
      return {
        status: 'completed',
        conclusion: 'success'
      }
  }
}

function statusToMarkdown(status) {
  switch (status) {
    case 'success':
      return ':white_check_mark: Passed'
    case 'failure':
      return ':x: Failed'
    case 'neutral':
      return ':bug: Errored'
    case 'timed_out':
      return ':hourglass: Timed-out'
  }
}

function getConclusionComment(conclusion, violations = [], details_url) {
  const status = statusToMarkdown(conclusion)
  let violationSummary = ""

  for (const violation of violations) {
    violationSummary += `**${violation.category}**\n`
    violationSummary += `(*${violation.severity}*) "${violation.name}" [${violation.count} occurrences]${violation.fail_simulation ? ' - :x: Failed simulation' : ''}\n\n`
  }
  if (violations.length === 0) {
    violationSummary = "No violations were found"
  }

  return `An execution simulation has been generated by **Lightlytics** [View simulation details](${details_url})\n` +
    status + (violations && violations.length > 0 ? ` [with ${violations.length} violations]` : '') +
    '\n\n' + violationSummary +
    '\n\n' + '> _This comment was added automatically by a git workflow to help DevOps teams predict what will be the impact of the proposed change after completing this PR_'
}
